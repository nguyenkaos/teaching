%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Template de Base
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstparamtype{%
\begin{lstlisting}
template<typename T> T maximum(T a, T b );
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstparaminteger{%
\begin{lstlisting}
template<int Value> struct number;
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstparamtmp{%
\begin{lstlisting}
template<template<class> class U, class T> 
U<T> make_container(std::size_t N, T const& value);
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstparamdefault{%
\begin{lstlisting}
template<class T = int, int Value = 0> struct number;
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lsttmpfunction{%
\begin{lstlisting}
template<typename T> T maximum(T a, T b )
{
  return a > b ? a : b;
}
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lsttmpfunctioncall{%
\begin{lstlisting}
int i,j,k;

k = maximum(i,j);
\end{lstlisting}}


\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstnormalswap{%
\begin{lstlisting}
void swap(int& a, int& b)
{
  int tmp(a);
  a = b;
  b = tmp;
}

void swap(float& a, float& b)
{
  float tmp(a);
  a = b;
  b = tmp;
}
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lsttmpswap{%
\begin{lstlisting}
template<class T> void swap(T& a, T& b)
{
  int tmp(a);
  a = b;
  b = tmp;
}
\end{lstlisting}}


\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lsttmppair{%
\begin{lstlisting}
template<class T1, class T2> struct pair
{
  pair() {}
  pair(T1 const& a, T2 const& b) : first_(a), second_(b) {}

  T1 first_;
  T2 second_;
};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstemptypair{%
\begin{lstlisting}
template<class T1, class T2> struct pair
{
  pair() {}
  pair(T1 const& a, T2 const& b) : first_(a), second_(b) {}

  T1 first_;
  T2 second_;
};

template<> struct pair<void,void>
{};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lsttmpreturn{%
\begin{lstlisting}
template<typename T> T Fonction() { return T(); } 

int x = Fonction();      // KO
int x = Fonction<int>(); // OK

template <typename T> void Fonction2( T x1, T x2 ) {} 

int x1 = 5;
double x2 = 6.5;

Fonction( x1, x2 );                        // KO
Fonction<double>( x1, x2 );                // OK
Fonction( static_cast<double>( x1 ), x2 ); // OK
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstpartialspec{%
\begin{lstlisting}
template<class T> struct add_ref           
{ typedef T& type; };

template<class T> struct add_ref<T&>       
{ typedef T& type; };

template<class T> struct add_ref<T const>  
{ typedef T const& type; };

template<class T> struct add_ref<T const&> 
{ typedef T const& type; };
\end{lstlisting}}


\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lststaticif{%
\begin{lstlisting}
template<bool Condition, typename T, typename F> class if_;

template<typename T, typename F> struct if_<true, T, F>
{
  typedef T_ type;
};

template<typename T, typename F> struct if_<false, T, F>
{
  typedef F type;
};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lststaticifusage{%
\begin{lstlisting}
int main()
{
  typename if_<true, int, void*>::result number(3);
  typename if_<false, int, void*>::result pointer(&number);

   typedef typename if_<(sizeof(void *) > sizeof(uint32_t))
                       , uint64_t
                       , uint32_t
                       >::type  integral_ptr_t;
	  
   integral_ptr_t ptr = reinterpret_cast<integral_ptr_t>(pointer);
}
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstdimension{%
\begin{lstlisting}
int main()
{
  mass<float> m = 3.4;
  distance<float> l = 4;
  duration<float> s = 0.1;

  force<float> f = m*l/(t*t);
}
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstisreferencea{%
\begin{lstlisting}
template<class T> struct is_reference
{
  static const bool value = false;
};
\end{lstlisting}}
\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstisreferenceb{%
\begin{lstlisting}
template<class T> struct is_reference<T&>
{
  static const bool value = true;
};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstaddreferencea{%
\begin{lstlisting}
template<class T> struct add_reference
{
  typedef T& type;
};

template<class T> struct remove_reference
{
  typedef T type;
};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstaddreferenceb{%
\begin{lstlisting}
template<class T> struct add_reference<T&>
{
  typedef T& type;
};

template<class T> struct remove_reference<T&>
{
  typedef T type;
};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstsfinaea{%
\begin{lstlisting}
template< class X
        , std::size_t (X::*)() const
        > struct member {};

template<class X> static char test(member<X,&X::size>*);
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstsfinaeb{%
\begin{lstlisting}
template<class X> static short test(...);
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstsfinae{%
\begin{lstlisting}
template<typename T> struct has_size
{
  template< class X
          , std::size_t (X::*)() const
          > struct member {};

  template<class X> static char  test(member<X,&X::size>*);
  template<class X> static short test( ... );

  static const bool value  = (sizeof(test<T>(0)) == 1);
};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstfacta{%
\begin{lstlisting}
template<int N> struct factorielle
{
  static const int value = N * factorielle<N-1>::value;
};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstfactb{%
\begin{lstlisting}
template<> struct factorielle<0>
{
  static const int value = 1;
};
\end{lstlisting}}

\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstunroll{%
\begin{lstlisting}
template<int N> void remplir( int* tab )
{
  tab[N-1] = 2*(N-1)+1;
  remplir<N-1>(tab);
}

template<> void remplir<0> ( int* tab ) {}

int t[10];
remplir<10>(&t[0]);
\end{lstlisting}}


\lstset{basicstyle=\scriptsize\ttfamily,frame=none,aboveskip=0bp,breaklines=true,belowskip=0bp,language=C++,showspaces=false, showstringspaces=false}\defverbatim[colored]\lstcopy{%
\begin{lstlisting}
template<typename I1, typename I2>
void copy(I1 f, I1 l, I2 o, bool_<false> const&)
{
  while(f != l) *o++ = *f++;
}

template<typename T>
void copy(const T* f, const T* l, T* o, bool_<true> const&)
{
  memmove(o, f, (l-f)*sizeof(T));
}

template<typename I1, typename I2>
void copy(I1 f, I1 l, I2 o)
{
 typedef typename std::iterator_traits<I1>::value_type value_type;
 copy(f, l, o, has_trivial_assign<value_type>());
}
\end{lstlisting}}

% !TEX encoding = UTF-8 Unicode
% -*- coding: UTF-8; -*-
% vim: set fenc=utf-8
\documentclass[svgnames]{beamer}
\setlength{\tabcolsep}{3em}
\usetheme[pageofpages=of,% String used between the current page and the
                         % total page count.
          titleline=true,
          alternativetitlepage=true% Use the fancy title page.
          ]{Torino}
\usecolortheme{metascale}
\usepackage{listings}

\ifxetex
  \usepackage{fontspec}
  \defaultfontfeatures{Mapping=tex-text}
  \setsansfont[ItalicFont={GillSansMTPro-BookItalic}]{GillSansMTPro-Book}
  \setmonofont{Inconsolata}
  \newcommand{\codefont}{\ttfamily}
\else
  \usepackage[utf8x]{inputenc}
  %\usepackage[nott]{inconsolata}
  %\newcommand{\codefont}{\fontfamily{fi4}\selectfont}
  \usepackage{inconsolata}
  \newcommand{\codefont}{\ttfamily}
\fi
\usepackage{graphicx}
\usepackage{color}
%\usepackage{multicol}
%\usepackage{array}
%\usepackage{colortbl}
\usepackage[frenchb]{babel}
%\usepackage{pgfplots}
%\usepackage{standalone}
\usepackage{relsize}

% setup tikz
%% \usepackage{tikz}
%% \usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
%% decorations.pathreplacing,decorations.pathmorphing,shapes,%
%% matrix,shapes.symbols,plotmarks,decorations.markings,shadows,%
%% snakes,backgrounds}
\def\print#1{\pgfmathparse{#1}\pgfmathresult}
\def\colx{Blue!40}
\def\coly{Blue!20}
\def\colz{white}

\def\C++{\textup{C}\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\relsize{-3}{\textbf{++}}}}

% vertical align box
\newcommand*{\vcenteredhbox}[1]{\begingroup
\setbox0=\hbox{#1}\parbox{\wd0}{\box0}\endgroup}

\lstdefinestyle{customcpp}{language=C++,
        basicstyle=\footnotesize\codefont,
        tabsize=2,
        numberstyle=\footnotesize,
        showstringspaces=false,
        %columns=fullflexible,
        keywordstyle=\color[rgb]{0.64,0.13,0.11},
        identifierstyle=,
        commentstyle=\color[rgb]{0.27,0.27,0.28},
        stringstyle=\color[rgb]{0.82,0.16,0.14},
        morekeywords=noexcept
        }

\definecolor{hlcolor}{rgb}{0.88,0.88,0.88}
\pgfdeclareimage[interpolate=true,width=9cm]{move}{move}

\NoAutoSpaceBeforeFDP

\title{Programmation C++ Avancée}
\subtitle{Session 5 -- Patrons de Fonction et de Classe}
\author{Joel Falcou \and Guillaume Melquiond}
\institute{Laboratoire de Recherche en Informatique}
\date{}

\subject{Computer Science}

\begin{document}
\include{sourcecode}
\include{slidelst}

\begin{frame}[plain]
\titlepage
\end{frame}
\setcounter{framenumber}{0}
\frame
{
  \frametitle{Contexte}
  \begin{block}{Qu'est-ce qu'un \texttt{template} ?}
  \begin{itemize}
  %\footnotesize
  \item Modèle générique de code de fonction ou de classe
  \item Paramétrable par des types concrets ou des valeurs constantes
  \item Spécifier ces paramètres \textbf{instancie} le \texttt{template} et génère du code
  \end{itemize}
  \end{block}

  \begin{block}{Pourquoi les templates ?}
  \begin{itemize}
  \item Base de la généricité en C++
  \item Support pour le polymorphisme statique
  \item Aller au-delà des macros du préprocesseur
  \end{itemize}
  \end{block}
}

\frame
{
  \frametitle{Principes de base}
  \begin{block}{Syntaxe}
  \begin{itemize}
  \item Paramétrage introduit par \texttt{template<>}
  \item Chaque paramètre peut être :
  \begin{itemize}
  \item un \textbf{type} introduit par les mots-clés \texttt{class} ou \texttt{typename}
  \lstparamtype
  \item une \textbf{valeur} de type booléen, entier ou pointeur
  \lstparaminteger
  \item un \textbf{type template} déclaré \textit{in situ}
  \lstparamtmp
  \item Ces paramètres peuvent avoir une valeur par défaut
  \lstparamdefault
  \end{itemize}
  \end{itemize}
  \end{block}
}

\frame
{
  \frametitle{Fonction template}
  \begin{block}{Principes}
  \begin{itemize}
  \footnotesize
  \item Une \textbf{fonction template} est un modèle de génération de fonction paramétrable
  \item Elle remplace avantageusement les macros en explicitant les types
  \bigskip
  \lsttmpfunction
  \item L'appel d'une \textbf{fonction template} s'effectue comme pour une fonction normale
  \item Le compilateur \textbf{infère} les paramètres à partir du type des arguments
  \bigskip
  \lsttmpfunctioncall
  \end{itemize}
  \end{block}
}

\frame
{
  \frametitle{Fonction template}
  \begin{block}{Exemple : la fonction \texttt{swap}}
  \begin{overlayarea}{\textwidth}{5cm}
  \only<1>{ \lstnormalswap }
  \only<2>{ \lsttmpswap    }
  \end{overlayarea}
  \end{block}
}


\frame
{
  \frametitle{Fonction template}
  \begin{block}{Algorithme de résolution d'un appel \texttt{template}}
  \footnotesize Choix de la bonne fonction lors d'un appel :
  \begin{enumerate}
  \footnotesize
  \item Parmi les fonctions non-\texttt{template} :
  \begin{enumerate}
  \footnotesize
  \item Une seule association exacte : \alert{résolution terminée}
  \item Plusieurs associations exactes : \alert{erreur}
  \item Aucune : \alert{allez en 2}
  \end{enumerate}
  \item Parmi les fonctions \texttt{template} :
  \begin{enumerate}
  \footnotesize
  \item Une seule association exacte : \alert{résolution terminée}
  \item Plusieurs associations exactes : \alert{erreur}
  \item Aucune : \alert{allez en 3}
  \end{enumerate}
  \item Réexaminer les fonctions non-\texttt{template} de façon classique
    avec d'éventuelles conversions de type
 \end{enumerate}
 \end{block}
}

\frame
{
  \frametitle{Fonction template}
  \begin{block}{Résolution d'un appel \texttt{template}}
  \bigskip
  \lsttmpreturn
  \end{block}
}

\frame
{
  \frametitle{Fonctions et inférence de type}
  \begin{block}{Impact sur le type de retour des fonctions}
  \begin{itemize}
  \item \texttt{auto} et \texttt{decltype} simplifient l'écriture
  du prototype des fonctions
  \item Notion de \textit{trailing return type}
  \end{itemize}

  \only<1>{\sourcecodecpp{code/trail03.cpp}}
  \only<2>{\sourcecodecpp{code/trail11.cpp}}
  \only<3>{\sourcecodecpp{code/trail14.cpp}}
  \end{block}
}

\frame
{
  \frametitle{Templates variadiques}
  \begin{block}{Application aux fonctions}
  \begin{itemize}
  \item Variante type-safe de l'ellipse \cpptext{...} du C
  \item Notion de \textit{parameter pack}
  \item Déduction automatique des types
  \end{itemize}

  \begin{overlayarea}{\textwidth}{4cm}
  \only<1>{\sourcecodecpplines{code/vararg.cpp}{3}{9}}
  \only<2>{\sourcecodecpplines{code/vararg.cpp}{11}{16}}
  \end{overlayarea}
  \end{block}
}

\frame
{
  \frametitle{Classe template}
  \begin{block}{Principes}
  \begin{itemize}
  \footnotesize
  \item Une \textbf{classe \texttt{template}} est un modèle de génération de classe paramétrable
  \item Elle permet de gérer des variantes de classes sans polymorphisme dynamique
  \item Les paramètres \texttt{template} sont à spécifier explicitement
  \item Une classe \texttt{template} ne devient un type complet que
    lorsqu'elle est entièrement spécifiée
  \end{itemize}
  \end{block}

  \begin{block}{Quelques détails}
  \begin{itemize}
  \footnotesize
  \item Une classe non \texttt{template} peut avoir des méthodes \texttt{template}
  \item Une classe \texttt{template} peut avoir des méthodes
    \texttt{template} utilisant des paramètres supplémentaires
  \item Si \texttt{A} hérite de \texttt{B}, et que \texttt{C} est une
    classe \texttt{template}, il n'existe aucun lien implicite
    entre \texttt{C<A>} et \texttt{C<B>}
  \end{itemize}
  \end{block}
}

\frame
{
  \frametitle{Classe template}
  \begin{block}{Exemple : la classe \texttt{pair<T1,T2>}}
  \bigskip
  \lsttmppair
  \end{block}
}

\frame
{
  \frametitle{Atelier pratique}
  \begin{block}{La classe \texttt{fixed\_array<T,N>}}
  \begin{itemize}
  \item \texttt{fixed\_array<T,N>} représente un tableau de \texttt{N} éléments de type T
  \item Proposez une implantation simple fournissant les opérations classiques sur les tableaux
  \end{itemize}
  \end{block}

  \begin{block}{Indices}
  \begin{itemize}
  \item \texttt{T} et \texttt{N} permettent de déclarer un \texttt{T tab[N]}
  \item Que deviennent \texttt{size}, \texttt{empty}, etc ?
  \end{itemize}
  \end{block}
}

\frame
{
  \frametitle{Spécialisation de template}
  \begin{block}{Cas d'utilisation}
  \begin{itemize}
  \item Quid d'un \texttt{fixed\_array<T,0>} ?
  \item Spécifier des comportement différents en fonctions du paramétrage
  \item Version statique du patron de conception ``Strategy'' ou ``State''
  \end{itemize}
  \end{block}

  \begin{block}{Mise en œuvre}
  \begin{itemize}
  \item Spécialisation totale
  \item Spécialisation partielle
  \end{itemize}
  \end{block}{}
}

\frame
{
  \frametitle{Spécialisation de template}
  \begin{block}{Spécialisation totale}
  Permet de spécifier un \texttt{template} entièrement pour un jeu de
  paramètres donnés
  \bigskip
  \lstemptypair
  \end{block}
}

\frame
{
  \frametitle{Spécialisation de template}
  \begin{block}{Spécialisation partielle}
  Permet de spécifier certains paramètres du \texttt{template} afin de
  spécialiser une partie de son comportement
  \bigskip
  \lstpartialspec
  \begin{center}\alert{Attention aux ambiguïtés !}\end{center}
  \end{block}
}

\frame
{
  \frametitle{Spécialisation de template}
  \begin{block}{Exemple : sélecteur conditionnel de type}
  \begin{overlayarea}{\textwidth}{5cm}
  \only<1>
  {
    \begin{block}{Spécification}
    \texttt{if\_<b,T1,T2>::type} s'évalue en \texttt{T1} si \texttt{b}
    vaut {true} et \texttt{T2} sinon
    \end{block}
  }
  \only<2>{ \sourcecodecpplines{code/if.cpp}{3}{13} }
  \only<3>{ \sourcecodecpplines{code/if.cpp}{15}{27} }
  \end{overlayarea}
  \end{block}
}

\end{document}
